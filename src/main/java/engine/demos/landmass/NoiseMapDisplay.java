package engine.demos.landmass;

import engine.components.AbstractComponent;
import engine.components.Geometry;
import engine.components.RenderableComponent;
import engine.render.Material;
import engine.resources.FilterMode;
import engine.resources.Texture2D;
import engine.scene.SceneNode;
import mesh.Mesh3D;
import mesh.creator.primitives.PlaneCreator;
import workspace.ui.Graphics;

/**
 * The {@code NoiseMapDisplay} class is responsible for rendering a noise map texture onto a 3D
 * plane. It creates a textured plane mesh that displays pixel data generated by procedural noise
 * algorithms. This class extends {@link AbstractComponent} and implements {@link
 * RenderableComponent}, making it suitable for integration within a 3D scene graph.
 *
 * <p>Usage:
 *
 * <ul>
 *   <li>Create an instance by specifying the width and height of the noise map.
 *   <li>Set pixel data using the {@link #setPixels(int[])} method.
 *   <li>The texture is automatically mapped onto a 3D plane and rendered during the scene's render
 *       phase.
 * </ul>
 *
 * <p>This class is typically used in terrain generation demos to visualize height maps or color
 * maps.
 */
public class NoiseMapDisplay extends AbstractComponent implements RenderableComponent {

  /** The 3D mesh representing a flat plane on which the noise map texture is rendered. */
  private Mesh3D planeMesh;

  /** The geometry component that combines the plane mesh with a material for rendering. */
  private Geometry planeGeometry;

  /** The texture representing the noise map, used to display pixel data on the plane mesh. */
  private Texture2D texture;

  /**
   * Constructs a new {@code NoiseMapDisplay} with a specified texture size.
   *
   * @param width the width of the noise map texture in pixels
   * @param height the height of the noise map texture in pixels
   */
  public NoiseMapDisplay(int width, int height) {
    createPlaneMesh();
    texture = new Texture2D(width, height);
    texture.setFilterMode(FilterMode.POINT); // Use point filtering for a pixelated look
  }

  /**
   * Initializes the plane mesh used for displaying the noise map. The plane is created with UV
   * coordinates to map the texture correctly.
   */
  private void createPlaneMesh() {
    planeMesh = new PlaneCreator(30).create();
    planeMesh.addUvCoordinate(0, 0);
    planeMesh.addUvCoordinate(1, 0);
    planeMesh.addUvCoordinate(1, 1);
    planeMesh.addUvCoordinate(0, 1);
    planeMesh.getFaceAt(0).setUvIndices(0, 1, 2, 3);
  }

  /**
   * Sets the pixel data for the noise map texture. The provided array should match the size of the
   * texture (width * height).
   *
   * @param pixels an array of pixel color values in ARGB format
   */
  public void setPixels(int[] pixels) {
    texture.setPixels(pixels);
    Material material = new Material.Builder().setDiffuseTexture(texture).build();
    planeGeometry = new Geometry(planeMesh, material);
  }

  /**
   * Returns the noise map texture used by this display.
   *
   * @return the {@link Texture2D} instance representing the noise map
   */
  public Texture2D getTexture() {
    return texture;
  }

  /**
   * Renders the noise map display using the provided {@link Graphics} context. The method checks if
   * the plane geometry is initialized before rendering.
   *
   * @param g the {@link Graphics} context used for rendering
   */
  @Override
  public void render(Graphics g) {
    if (planeGeometry == null) {
      return;
    }
    planeGeometry.render(g);
  }

  /**
   * Called each frame to update the component's state. This implementation does not perform any
   * updates, but can be extended if needed.
   *
   * @param tpf time per frame, in seconds
   */
  @Override
  public void update(float tpf) {
    // No updates are required for this component
  }

  /**
   * Called when this component is attached to a {@link SceneNode}. This method is a lifecycle hook
   * that can be used to initialize resources or state.
   */
  @Override
  public void onAttach() {
    // No special actions needed on attach
  }

  /**
   * Called when this component is detached from a {@link SceneNode}. This method is a lifecycle
   * hook that can be used to clean up resources or state.
   */
  @Override
  public void onDetach() {
    // No special actions needed on detach
  }
}
